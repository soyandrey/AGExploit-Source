

using System;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;

namespace agexploit
{
  internal class DllInjector
  {
    public enum DllInjectionResult
    {
      DllNotFound,
      GameProcessNotFound,
      InjectionFailed,
      Success,
    }

    public sealed class Injector
    {
      private static readonly IntPtr INTPTR_ZERO = (IntPtr) 0;
      private static DllInjector.Injector _instance;

      [DllImport("kernel32.dll", SetLastError = true)]
      private static extern IntPtr OpenProcess(
        uint dwDesiredAccess,
        int bInheritHandle,
        uint dwProcessId);

      [DllImport("kernel32.dll", SetLastError = true)]
      private static extern int CloseHandle(IntPtr hObject);

      [DllImport("kernel32.dll", SetLastError = true)]
      private static extern IntPtr GetProcAddress(IntPtr hModule, string lpProcName);

      [DllImport("kernel32.dll", SetLastError = true)]
      private static extern IntPtr GetModuleHandle(string lpModuleName);

      [DllImport("kernel32.dll", SetLastError = true)]
      private static extern IntPtr VirtualAllocEx(
        IntPtr hProcess,
        IntPtr lpAddress,
        IntPtr dwSize,
        uint flAllocationType,
        uint flProtect);

      [DllImport("kernel32.dll", SetLastError = true)]
      private static extern int WriteProcessMemory(
        IntPtr hProcess,
        IntPtr lpBaseAddress,
        byte[] buffer,
        uint size,
        int lpNumberOfBytesWritten);

      [DllImport("kernel32.dll", SetLastError = true)]
      private static extern IntPtr CreateRemoteThread(
        IntPtr hProcess,
        IntPtr lpThreadAttribute,
        IntPtr dwStackSize,
        IntPtr lpStartAddress,
        IntPtr lpParameter,
        uint dwCreationFlags,
        IntPtr lpThreadId);

      public static DllInjector.Injector GetInstance
      {
        get
        {
          if (DllInjector.Injector._instance == null)
            DllInjector.Injector._instance = new DllInjector.Injector();
          return DllInjector.Injector._instance;
        }
      }

      private Injector()
      {
      }

      public DllInjector.DllInjectionResult Inject(string sProcName, string sDllPath)
      {
        if (!File.Exists(sDllPath))
          return DllInjector.DllInjectionResult.DllNotFound;
        uint pToBeInjected = 0;
        Process[] processes = Process.GetProcesses();
        for (int index = 0; index < processes.Length; ++index)
        {
          if (processes[index].ProcessName == sProcName)
          {
            pToBeInjected = (uint) processes[index].Id;
            break;
          }
        }
        return pToBeInjected == 0U ? DllInjector.DllInjectionResult.GameProcessNotFound : (!this.BInject(pToBeInjected, sDllPath) ? DllInjector.DllInjectionResult.InjectionFailed : DllInjector.DllInjectionResult.Success);
      }

      private unsafe bool BInject(uint pToBeInjected, string sDllPath)
      {
        IntPtr num1 = DllInjector.Injector.OpenProcess(1082U, 1, pToBeInjected);
        if (num1 == DllInjector.Injector.INTPTR_ZERO)
          return false;
        IntPtr procAddress = DllInjector.Injector.GetProcAddress(DllInjector.Injector.GetModuleHandle("kernel32.dll"), "LoadLibraryA");
        if (procAddress == DllInjector.Injector.INTPTR_ZERO)
          return false;
        IntPtr num2 = DllInjector.Injector.VirtualAllocEx(num1, (IntPtr) (void*) null, (IntPtr) sDllPath.Length, 12288U, 64U);
        if (num2 == DllInjector.Injector.INTPTR_ZERO)
          return false;
        byte[] bytes = Encoding.ASCII.GetBytes(sDllPath);
        if (DllInjector.Injector.WriteProcessMemory(num1, num2, bytes, (uint) bytes.Length, 0) == 0 || DllInjector.Injector.CreateRemoteThread(num1, (IntPtr) (void*) null, DllInjector.Injector.INTPTR_ZERO, procAddress, num2, 0U, (IntPtr) (void*) null) == DllInjector.Injector.INTPTR_ZERO)
          return false;
        DllInjector.Injector.CloseHandle(num1);
        return true;
      }
    }
  }
}
